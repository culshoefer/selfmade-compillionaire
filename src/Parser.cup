import java_cup.runtime.*;
import java.util.ArrayList;

scan with {: return lexer.next_token(); :};

parser code {:

  public boolean  debug(){return debug;}
  public void     debug(boolean b){debug = b;}
  public boolean  syntaxErrors;
  private boolean debug = true;

  static class Node {
    public ArrayList<Node> children;
    private static int globalCounter = 0;

    public int counter;
    private Object value;

    public Node(Object value){
      Node.globalCounter += 1;
      this.counter = Node.globalCounter;
      this.value = value;
      this.children = new ArrayList<Node>();
    }

    public void addChild(Node n){ children.add(n); }

    public static Node fromObject(Object o) {
        Node node;
        if(o instanceof Node) node = (Node) o;
        else if(o instanceof String) node = new Node((String) o);
        else node = new Node(o.toString());
        return node;
    }

    public static Node n(Object object, Object... children) {
        Node node = Node.fromObject(object);
        for (Object child : children) {
            node.addChild(Node.fromObject(child));
        }
        return node;
    }

    public String toString(){
      String ret = "";
      ret += String.format("%d [label=\"%s\"];",
                            counter, value.toString());
      for(Node n: children){
        ret += String.format("%d -> %d;", this.counter, n.counter);
        ret += n.toString();
      }
      return ret;
    }
  }

  private Lexer lexer;

  public Parser(Lexer lex) {
    super(lex);
    lexer = lex;
  }

  public void syntax_error(Symbol current_token) {
  report_error(
  "Syntax error at line " + (current_token.left+1) + ", column "
  + current_token.right, null
  );
}

:};

/**
  * TERMINALS
  */

// Identifier
terminal ID;
// Basic data representations
terminal INTEGER, FLOAT, BOOL, CHAR;
// Bracket extravaganza
terminal LPAREN, RPAREN; // ()
terminal LCURLY, RCURLY; // {}
// Arithemtic operators
terminal PLUS, MINUS, MULT, DIV;
// Comparions operators
terminal EQ, LESS, LESS_EQ; // =, <, <=
// Dictionaries and sequences (collections)
terminal DICT_START, SEQ_START, COLLECT_END; // dict<, seq<, collect_end
// Types
terminal TYPE_BOOL, TYPE_CHAR, TYPE_INT, TYPE_RAT, TYPE_FLOAT, TYPE_STRING, TYPE_TOP;
// Other operators
terminal CONCAT, SEMICOL, COLON, ASSIGN, COMMA; // ::, ;, :, :=, \,
// Comments
terminal MULTI_LINE_COMMENT, SINGLE_LINE_COMMENT; // /#...#/, #...

// TODO: Test that function actually returns something of that type (i.e. if func is supposed to have return type int, check there's return int somewhere)
// TODO: Test for allowed/disallowed ASCII characters as string/char AND for variable names
// TODO: Test for function calls/predicates before call
// TODO: Test for capital s in seq, and variations of this
// TODO: Implication
// TODO: Seq length checking
// TODO: Rationals
// TODO: Loop
// TODO: If
// TODO: Break
// TODO: Test Function calls
// TODO: Don't allow keywords as e.g. function names
// TODO: Check for fields access (e.g. p.age)
// TODO: Assignment to custom type
// TODO: Null value
// TODO: Alias
// TODO: Are declarations only allowed before main?
/**
  * NON-TERMINALS
  */

// Variables and types
nonterminal variable_decl_init, var_decl, type, type_decl;
nonterminal type_seq, type_dict, collect_type;
// Comments
nonterminal any_comment;
// Parameters
nonterminal top_level_formal_parameter_list, formal_parameter_list, formal_parameter;


/**
  * OLD STUFF
  */

// Do something with ILLEGAL_CHARARCTER or drop it.
terminal BADCHAR; //TODO: Return this? When is it used?
terminal PRINT, READ, RETURN, MAIN, FDEF;

nonterminal stmnts, stmnt, top_level;
nonterminal full_exp, simple_exp, operator;
nonterminal print_statement, read_statement, return_statement;
nonterminal funcs_or_main, main_func, normal_func, normal_func_body;
nonterminal funcs_or_global_decls, funcs, func_param_decl, func_body_no_return, func_body_with_return;

precedence left PLUS, MINUS;
precedence left DIV, MULT;

top_level
::=
    funcs_or_global_decls:fog {: if(debug()) System.out.println((Node)fog); :}
;

//any_comment ::=


funcs_or_global_decls // TODO: Add global variables to this
::=
    funcs_or_main:fs {:RESULT=Node.n(fs);:}
;


//TODO add empty return for main (or any function)
//TODO add error code return for main
main_func
::=
    MAIN func_param_decl:p func_body_no_return:fb {:RESULT=Node.n("MAIN_FUNC", p, fb);:}
  | MAIN func_body_no_return:fb {:RESULT=Node.n("MAIN_FUNC", fb);:}
;

funcs_or_main
::=
    main_func:mf funcs:fu {:RESULT=Node.n("MAIN_THEN_FUNC", mf, fu);:}
  | normal_func:nf funcs_or_main:fum {:RESULT=Node.n("FUNC_THEN_MAYBE_MAIN", nf, fum);:}
;

funcs
::=
    normal_func:f funcs:fs {:RESULT=Node.n("FUNC_THEN_FUNCS", f, fs);:}
  | /* nuffin */ {:RESULT=Node.n("FUNCS_END");:}
;

// TODO: Add return param
normal_func
::=
    FDEF ID:i func_param_decl:p normal_func_body:fb {:RESULT=Node.n("FDEF", i, p, fb);:}
;


//TODO add the actual args
func_param_decl
::=
    LPAREN top_level_formal_parameter_list RPAREN {:RESULT=Node.n("PARAM_DECL");:}
;

top_level_formal_parameter_list
::=
    formal_parameter_list:ne {:RESULT=Node.n(ne);:}
   | /* nuffin */ {:RESULT=Node.n("NO_PARAMS");:}
;

formal_parameter_list
::= var_decl:f COMMA formal_parameter_list:fl {:RESULT=Node.n("NON_ENDING_PARAMS_LIST", f, fl);:}
   | var_decl:f {:RESULT=Node.n(f);:}
;

normal_func_body
::=
    func_body_no_return:n {:RESULT=Node.n(n);:}
  | func_body_with_return:r{:RESULT=Node.n(r);:}
;

// TODO: Add declaration between statements
func_body_no_return
::=
    LCURLY stmnts:ss RCURLY SEMICOL {:RESULT=Node.n("FUNC_BODY_NO_RETURN", ss);:}
;

func_body_with_return
::=
    LCURLY stmnts:ss RCURLY type_decl:td SEMICOL {:RESULT=Node.n("FUNC_BODY_WITH_RETURN", ss, td);:}
;

stmnts
::=
    stmnt:s {:RESULT=Node.n(s);:}
  | stmnt:s stmnts:ss {:RESULT=Node.n(s, ss);:}
;

//TODO: Restrict return statement to functions with return type
stmnt
::=
    variable_decl_init:s {:RESULT=Node.n(s);:}
  | full_exp:s {:RESULT=Node.n(s);:}
  | read_statement:r {:RESULT=Node.n(r);:}
  | print_statement:p {:RESULT=Node.n(p);:}
  | return_statement:re {:RESULT=Node.n(re);:}
;

full_exp
::=
    simple_exp:e SEMICOL {:RESULT=Node.n(e);:}
;

simple_exp
::=
    INTEGER:i {:RESULT=Node.n(i);:}
  | BOOL:i {:RESULT=Node.n(i);:}
  | ID:i {:RESULT=Node.n(i);:}
  | simple_exp:e1 operator:o simple_exp:e2 {:RESULT=Node.n(o, e1, e2);:}
  | LPAREN simple_exp:e RPAREN {:RESULT=Node.n("PARENS", "(", e, ")");:}
;

read_statement
::=
    READ ID:i SEMICOL {:RESULT=Node.n("READ", i);:}
;

print_statement
::=
    PRINT full_exp:e {:RESULT=Node.n("PRINT", e);:}
;

return_statement
::=
    RETURN full_exp:e {:RESULT = Node.n("RETURN", e);:}
;

operator
::=
    PLUS  {:RESULT=Node.n("+");:}
  | MINUS {:RESULT=Node.n("-");:}
  | MULT  {:RESULT=Node.n("*");:}
  | DIV   {:RESULT=Node.n("/");:}
;

variable_decl_init
::=
    var_decl:v ASSIGN full_exp:e {:RESULT=Node.n("ASSIGNMENT", v, e);:}
  | var_decl:v SEMICOL {:RESULT=Node.n(v);:}
;

var_decl
::=
    ID:i type_decl:td {:RESULT=Node.n("DECLARATION", i ,td);:}
;

type_decl
::=
    COLON type:t {:RESULT=Node.n("TYPE DECLARATION", t);:}
;

type
::=
    TYPE_BOOL {:RESULT=Node.n("BOOL");:}
  | TYPE_CHAR {:RESULT=Node.n("CHAR");:}
  | TYPE_INT {:RESULT=Node.n("INT");:}
  | TYPE_RAT {:RESULT=Node.n("RAT");:}
  | TYPE_FLOAT {:RESULT=Node.n("FLOAT");:}
  | TYPE_STRING {:RESULT=Node.n("STRING");:}
  | type_seq:s {:RESULT=Node.n(s);:}
  | type_dict:d {:RESULT=Node.n(d);:}
  | ID:i {:RESULT=Node.n("CUSTOM_TYPE", i);:}
;

collect_type
::=
    type:t {:RESULT=Node.n(t);:}
  | TYPE_TOP {:RESULT=Node.n("TOP");:}
;

type_seq
::=
    SEQ_START collect_type:t COLLECT_END {:RESULT=Node.n("SEQ", t);:}
;

type_dict
::=
    DICT_START type:t1 COMMA collect_type:t2 COLLECT_END {:RESULT = Node.n("DICT", t1, t2);:}
;

