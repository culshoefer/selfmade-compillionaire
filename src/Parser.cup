import java_cup.runtime.*;
import java.util.ArrayList;

scan with {: return lexer.next_token(); :};

parser code {:

  public boolean  debug(){return debug;}
  public void     debug(boolean b){debug = b;}
  public boolean  syntaxErrors;
  private boolean debug = true;

  static class Node {
    public ArrayList<Node> children;
    private static int globalCounter = 0;

    public int counter;
    private Object value;

    public Node(Object value){
      Node.globalCounter += 1;
      this.counter = Node.globalCounter;
      this.value = value;
      this.children = new ArrayList<Node>();
    }

    public void addChild(Node n){ children.add(n); }

    public String toString(){
      String ret = "";
      ret += String.format("%d [label=\"%s\"];",
                            counter, value.toString());
      for(Node n: children){
        ret += String.format("%d -> %d;", this.counter, n.counter);
        ret += n.toString();
      }
      return ret;
    }
  }

  private Lexer lexer;

  public Parser(Lexer lex) {
    super(lex);
    lexer = lex;
  }

  public void syntax_error(Symbol current_token) {
  report_error(
  "Syntax error at line " + (current_token.left+1) + ", column "
  + current_token.right, null
  );
}

:};

/**
  * TERMINALS
  */

// Bracket extravaganza
terminal LPAREN, RPAREN; // ()
terminal LCURLY, RCURLY; // {}
// Arithemtic operators
terminal PLUS, MINUS, MULT, DIV;
// Comparions operators
terminal EQ, LESS, LESS_EQ; // =, <, <=
// Dictionaries and sequences (collections)
terminal DICT_START, SEQ_START, COLLECT_END; // dict<, seq<, collect_end
// Types
terminal TYPE_BOOL, TYPE_CHAR, TYPE_INT, TYPE_RAT, TYPE_FLOAT, TYPE_STRING, TYPE_TOP;
// Other operators
terminal CONCAT, SEMICOL, COLON, ASSIGN, COMMA; // ::, ;, :, :=, \,


/**
  * NON-TERMINALS
  */

// Variables and types
nonterminal variable_declaration_initialisation, variable_declaration, type, type_declaration;
nonterminal type_seq, type_dict, collection_type;


/**
  * OLD STUFF
  */

// Do something with ILLEGAL_CHARARCTER or drop it.
terminal INTEGER, FLOAT, BOOL, CHAR, IDENTIFIER, LET;
terminal BADCHAR; //TODO: Return this? When is it used?
terminal PRINT, READ, RETURN, MAIN, FDEF;

nonterminal statements, statement, top_level;
nonterminal full_exp, simple_exp, operator;
nonterminal print_statement, read_statement, return_statement;
nonterminal functions_or_main, main_function, normal_function, normal_function_body;
nonterminal functions_or_global_declarations, functions, func_param_declaration, non_return_function_body, return_function_body;

precedence left PLUS, MINUS;
precedence left DIV, MULT;

top_level ::= functions_or_global_declarations:fog {:
                if(debug()) System.out.println((Node)fog);
              :}
            ;

// TODO: Add global variables to this
functions_or_global_declarations ::= functions_or_main:fs {: RESULT = (Node) fs; :};

//TODO add empty return for main (or any function)
//TODO add error code return for main
main_function ::= MAIN func_param_declaration:p non_return_function_body:fb {:
                          Node n = new Node("MainFunc");
                          n.addChild((Node) p);
                          n.addChild((Node) fb);
                          RESULT = n;
                    :}
                | MAIN non_return_function_body:fb {:
                          Node n = new Node("MainFunc");
                          n.addChild((Node) fb);
                          RESULT = n;
                    :}
                ;

functions_or_main ::= main_function:mf functions:fu {:
                          Node n = new Node("Main, then other funcs");
                          n.addChild((Node) mf);
                          n.addChild((Node) fu);
                          RESULT = n;
                      :}
                    | normal_function:nf functions_or_main:fum {:
                          Node n = new Node("Normal func, then maybe main");
                          n.addChild((Node) nf);
                          n.addChild((Node) fum);
                          RESULT = n;
                      :};

functions ::= normal_function:f functions:fs {:
                    // TODO: Fix node generation
                    Node n = (Node)f;
                    n.addChild((Node)fs);
                    RESULT = n;
               :}
               | /* nuffin */ {: RESULT = new Node("Functions (end)"); :}
               ;

// TODO: Add return param
normal_function ::= FDEF IDENTIFIER:i func_param_declaration:p normal_function_body:fb {:
                        Node n = new Node("FDef");
                        n.addChild((Node) new Node(i));
                        n.addChild((Node) p);
                        n.addChild((Node) fb);
                        RESULT = n;
                    :};

//TODO add the actual args
func_param_declaration ::= LPAREN RPAREN {: RESULT = new Node("Param Declaration"); :};



normal_function_body ::= non_return_function_body:n {: RESULT = (Node) n; :}
                       | return_function_body:r {: RESULT = (Node) r; :}
                       ;

// TODO: Add declaration between statements
non_return_function_body ::= LCURLY statements:ss RCURLY SEMICOL {:
                    Node n = new Node("Function Body without return");
                    n.addChild(new Node("LCURLY"));
                    n.addChild((Node) ss);
                    n.addChild(new Node("RCURLY"));
                    n.addChild(new Node(";"));
                    RESULT = n;
                  :};

return_function_body ::= LCURLY statements:ss RCURLY type_declaration:td SEMICOL {:
                         Node n = new Node("Function Body with return");
                         n.addChild((Node) ss);
                         n.addChild((Node) td);
                         RESULT = n;
                         :}
                     ;

statements ::= statement:s {: RESULT = (Node) s; :}
             | statement:s statements:ss {:
                                 Node n = (Node)ss;
                                 n.addChild((Node)s);
                                 RESULT = n;
                              :}
             ;

//TODO: Restrict return statement to functions with return type
statement ::= variable_declaration_initialisation:s {:
                RESULT = (Node)s;
              :}
            | full_exp:s {:
                RESULT = (Node)s;
              :}
             | read_statement:r {: RESULT = (Node) r; :}
             | print_statement:p {: RESULT = (Node) p; :}
             | return_statement:re {: RESULT = (Node) re; :}
            ;

full_exp ::= simple_exp:e SEMICOL {: RESULT = (Node)e; :};

simple_exp ::= INTEGER:i    {: RESULT = new Node(i); :}
             | IDENTIFIER:i {: RESULT = new Node(i); :}
             | simple_exp:e1 operator:o simple_exp:e2 {:
                  Node n = (Node)o;
                  n.addChild((Node)e1);
                  n.addChild((Node)e2);
                  RESULT = n;
               :}
             | LPAREN simple_exp:e RPAREN {:
                 Node n = new Node("parens");
                 n.addChild(new Node("("));
                 n.addChild((Node)e);
                 n.addChild(new Node(")"));
                 RESULT = e;
               :}
             ;

read_statement ::= READ IDENTIFIER:i SEMICOL {:
                    Node n = new Node("READ");
                    n.addChild(new Node(i));
                    RESULT = n;
                :}
                ;
print_statement ::= PRINT full_exp:e {:
                    Node n = new Node("PRINT");
                    n.addChild((Node) e);
                    RESULT = n;
                :}
                ;

return_statement ::= RETURN full_exp:e {:
                    Node n = new Node("RETURN");
                    n.addChild((Node) e);
                    RESULT = n;
                  :}
                  ;

operator ::= PLUS  {: RESULT = new Node("+"); :}
           | MINUS {: RESULT = new Node("-"); :}
           | MULT  {: RESULT = new Node("*"); :}
           | DIV   {: RESULT = new Node("/"); :}
           ;

variable_declaration_initialisation ::= variable_declaration:v ASSIGN full_exp:e {:
                                            Node n = new Node("ASSIGNMENT");
                                            n.addChild((Node)v);
                                            n.addChild((Node)e);
                                            RESULT = n;
                                        :}
                                      | variable_declaration:v SEMICOL {:
                                            RESULT = (Node)v;
                                        :}
                                        ;

variable_declaration ::= IDENTIFIER:i type_declaration:td {:
    Node n = new Node("DECLARATION");
    n.addChild(new Node(i));
    n.addChild((Node)td);
    RESULT = n;
:};

type_declaration ::= COLON type:t {:
                        Node n = new Node("TYPE DECLARATION");
                        n.addChild((Node)t);
                        RESULT = n;
                     :};

type ::= TYPE_BOOL {: RESULT = new Node("BOOL"); :}
       | TYPE_CHAR {: RESULT = new Node("CHAR"); :}
       | TYPE_INT {: RESULT = new Node("INT"); :}
       | TYPE_RAT {: RESULT = new Node("RAT"); :}
       | TYPE_FLOAT {: RESULT = new Node("FLOAT"); :}
       | TYPE_STRING {: RESULT = new Node("STRING"); :}
       | type_seq:s {: RESULT = (Node)s; :}
       | type_dict:d {: RESULT = (Node)d; :}
       | IDENTIFIER:i {:
            Node n = new Node("CUSTOM TYPE");
            n.addChild((Node)i);
            RESULT = n;
       :}
       ;

collection_type ::= type:t {: RESULT = (Node)t; :}
                  | TYPE_TOP {: RESULT = new Node("TOP"); :}
                  ;

type_seq ::= SEQ_START collection_type:t COLLECT_END {:
    Node n = new Node("SEQUENCE");
    n.addChild((Node)t);
    RESULT = n;
:};

type_dict ::= DICT_START type:t1 COMMA collection_type:t2 COLLECT_END {:
    Node n = new Node("DICTIONARY");
    n.addChild((Node)t1);
    n.addChild((Node)t2);
    RESULT = n;
:};

