import java_cup.runtime.*;
import java.util.ArrayList;

scan with {: return lexer.next_token(); :};

parser code {:

  public boolean  debug(){return debug;}
  public void     debug(boolean b){debug = b;}
  public boolean  syntaxErrors;
  private boolean debug = true;

  static class Node {
    public ArrayList<Node> children;
    private static int globalCounter = 0;

    public int counter;
    private Object value;

    public Node(Object value){
      Node.globalCounter += 1;
      this.counter = Node.globalCounter;
      this.value = value;
      this.children = new ArrayList<Node>();
    }

    public void addChild(Node n){ children.add(n); }

    public static Node fromObject(Object o) {
        Node node;
        if(o instanceof Node) node = (Node) o;
        else if(o instanceof String) node = new Node((String) o);
        else node = new Node(o.toString());
        return node;
    }

    public static Node fromObjects(Object object, Object... children) {
        Node node = Node.fromObject(object);
        for (Object child : children) {
            node.addChild(Node.fromObject(child));
        }
        return node;
    }

    public String toString(){
      String ret = "";
      ret += String.format("%d [label=\"%s\"];",
                            counter, value.toString());
      for(Node n: children){
        ret += String.format("%d -> %d;", this.counter, n.counter);
        ret += n.toString();
      }
      return ret;
    }
  }

  private Lexer lexer;

  public Parser(Lexer lex) {
    super(lex);
    lexer = lex;
  }

  public void syntax_error(Symbol current_token) {
  report_error(
  "Syntax error at line " + (current_token.left+1) + ", column "
  + current_token.right, null
  );
}

:};

/**
  * TERMINALS
  */

// Bracket extravaganza
terminal LPAREN, RPAREN; // ()
terminal LCURLY, RCURLY; // {}
// Arithemtic operators
terminal PLUS, MINUS, MULT, DIV;
// Comparions operators
terminal EQ, LESS, LESS_EQ; // =, <, <=
// Dictionaries and sequences (collections)
terminal DICT_START, SEQ_START, COLLECT_END; // dict<, seq<, collect_end
// Types
terminal TYPE_BOOL, TYPE_CHAR, TYPE_INT, TYPE_RAT, TYPE_FLOAT, TYPE_STRING, TYPE_TOP;
// Other operators
terminal CONCAT, SEMICOL, COLON, ASSIGN, COMMA; // ::, ;, :, :=, \,
// Comments
terminal MULTI_LINE_COMMENT, SINGLE_LINE_COMMENT; // /#...#/, #...


/**
  * NON-TERMINALS
  */

// Variables and types
nonterminal variable_declaration_initialisation, variable_declaration, type, type_declaration;
nonterminal type_seq, type_dict, collection_type;
// Comments
nonterminal any_comment;


/**
  * OLD STUFF
  */

// Do something with ILLEGAL_CHARARCTER or drop it.
terminal INTEGER, FLOAT, BOOL, CHAR, IDENTIFIER, LET;
terminal BADCHAR; //TODO: Return this? When is it used?
terminal PRINT, READ, RETURN, MAIN, FDEF;

nonterminal statements, statement, top_level;
nonterminal full_exp, simple_exp, operator;
nonterminal print_statement, read_statement, return_statement;
nonterminal functions_or_main, main_function, normal_function, normal_function_body;
nonterminal functions_or_global_declarations, functions, func_param_declaration, non_return_function_body, return_function_body;

precedence left PLUS, MINUS;
precedence left DIV, MULT;

top_level ::= functions_or_global_declarations:fog {:
                if(debug()) System.out.println((Node)fog);
              :}
            ;

//any_comment ::=

// TODO: Add global variables to this
functions_or_global_declarations ::= functions_or_main:fs {: RESULT = (Node) fs; :};

//TODO add empty return for main (or any function)
//TODO add error code return for main
main_function ::= MAIN func_param_declaration:p non_return_function_body:fb {:
                          RESULT = Node.fromObjects("MAIN_FUNC", p, fb);
                    :}
                | MAIN non_return_function_body:fb {:
                          RESULT = Node.fromObjects("MAIN_FUNC", fb);
                    :}
                ;

functions_or_main ::= main_function:mf functions:fu {:
                          RESULT = Node.fromObjects("MAIN_THEN_FUNC", mf, fu);
                      :}
                    | normal_function:nf functions_or_main:fum {:
                          RESULT = Node.fromObjects("FUNC_THEN_MAYBE_MAIN", nf, fum);
                      :};

functions ::= normal_function:f functions:fs {:
                    RESULT = Node.fromObjects("FUNC_THEN_FUNCS", f, fs);
               :}
               | /* nuffin */ {: RESULT = new Node("Functions (end)"); :}
               ;

// TODO: Add return param
normal_function ::= FDEF IDENTIFIER:i func_param_declaration:p normal_function_body:fb {:
                        RESULT = Node.fromObjects("FDEF", i, p, fb);
                    :};

//TODO add the actual args
func_param_declaration ::= LPAREN RPAREN {: RESULT = new Node("Param Declaration"); :};



normal_function_body ::= non_return_function_body:n {: RESULT = (Node) n; :}
                       | return_function_body:r {: RESULT = (Node) r; :}
                       ;

// TODO: Add declaration between statements
non_return_function_body ::= LCURLY statements:ss RCURLY SEMICOL {:
                    RESULT = Node.fromObjects("FUNC_BODY_NO_RETURN", ss);
                  :};

return_function_body ::= LCURLY statements:ss RCURLY type_declaration:td SEMICOL {:
                         RESULT = Node.fromObjects("FUNC_BODY_WITH_RETURN", ss, td);
                     :}
                     ;

statements ::= statement:s {: RESULT = (Node) s; :}
             | statement:s statements:ss {:
                                 RESULT = Node.fromObjects(s, ss);
                              :}
             ;

//TODO: Restrict return statement to functions with return type
statement ::= variable_declaration_initialisation:s {:
                RESULT = (Node)s;
              :}
            | full_exp:s {:
                RESULT = (Node)s;
              :}
             | read_statement:r {: RESULT = (Node) r; :}
             | print_statement:p {: RESULT = (Node) p; :}
             | return_statement:re {: RESULT = (Node) re; :}
            ;

full_exp ::= simple_exp:e SEMICOL {: RESULT = (Node)e; :};

simple_exp ::= INTEGER:i    {: RESULT = new Node(i); :}
             | IDENTIFIER:i {: RESULT = new Node(i); :}
             | simple_exp:e1 operator:o simple_exp:e2 {:
                  RESULT = Node.fromObjects(o, e1, e2);
               :}
             | LPAREN simple_exp:e RPAREN {:
                 RESULT = Node.fromObjects("PARENS", "(", e, ")");
               :}
             ;

read_statement ::= READ IDENTIFIER:i SEMICOL {:
                    RESULT = Node.fromObjects("READ", i);
                :}
                ;
print_statement ::= PRINT full_exp:e {:
                    RESULT = Node.fromObjects("PRINT", e);
                :}
                ;

return_statement ::= RETURN full_exp:e {:
                    RESULT = Node.fromObjects("RETURN", e);
                  :}
                  ;

operator ::= PLUS  {: RESULT = new Node("+"); :}
           | MINUS {: RESULT = new Node("-"); :}
           | MULT  {: RESULT = new Node("*"); :}
           | DIV   {: RESULT = new Node("/"); :}
           ;

variable_declaration_initialisation ::= variable_declaration:v ASSIGN full_exp:e {:
                                            RESULT = Node.fromObjects("ASSIGNMENT", v, e);
                                        :}
                                      | variable_declaration:v SEMICOL {:
                                            RESULT = (Node)v;
                                        :}
                                        ;

variable_declaration ::= IDENTIFIER:i type_declaration:td {:
    RESULT = Node.fromObjects("DECLARATION", i, td);
:};

type_declaration ::= COLON type:t {:
                        RESULT = Node.fromObjects("TYPE DECLARATION", t);
                     :};

type ::= TYPE_BOOL {: RESULT = new Node("BOOL"); :}
       | TYPE_CHAR {: RESULT = new Node("CHAR"); :}
       | TYPE_INT {: RESULT = new Node("INT"); :}
       | TYPE_RAT {: RESULT = new Node("RAT"); :}
       | TYPE_FLOAT {: RESULT = new Node("FLOAT"); :}
       | TYPE_STRING {: RESULT = new Node("STRING"); :}
       | type_seq:s {: RESULT = (Node)s; :}
       | type_dict:d {: RESULT = (Node)d; :}
       | IDENTIFIER:i {: RESULT = Node.fromObjects("CUSTOM_TYPE", i); :}
       ;

collection_type ::= type:t {: RESULT = (Node)t; :}
                  | TYPE_TOP {: RESULT = new Node("TOP"); :}
                  ;

type_seq ::= SEQ_START collection_type:t COLLECT_END {:
    RESULT = Node.fromObjects("SEQUENCE", t);
:};

type_dict ::= DICT_START type:t1 COMMA collection_type:t2 COLLECT_END {:
    RESULT = Node.fromObjects("DICTIONARY", t1, t2);
:};

