import java_cup.runtime.*;
import java.util.ArrayList;

scan with {: return lexer.next_token(); :};

parser code {:

  public boolean  debug(){return debug;}
  public void     debug(boolean b){debug = b;}
  public boolean  syntaxErrors;
  private boolean debug = false;

  static class Node {
    public ArrayList<Node> children;
    private static int globalCounter = 0;

    public int counter;
    private Object value;

    public boolean printed = false;
    public boolean childrenPrinted = false;

    public Node(Object value){
      Node.globalCounter += 1;
      this.counter = Node.globalCounter;
      this.value = value;
      this.children = new ArrayList<Node>();
    }

    public void addChild(Node n){ children.add(n); }

    public static Node fromObject(Object o) {
        Node node;
        if(o instanceof Node) node = (Node) o;
        else if(o instanceof String) node = new Node((String) o);
        else node = new Node(o.toString());
        System.out.println(node);
        return node;
    }

    public static Node n(Object object, Object... children) {
        Node node = Node.fromObject(object);
        for (Object child : children) {
            node.addChild(Node.fromObject(child));
        }
        return node;
    }

    public String toString(){
      String ret = "";
        if (!this.printed) {
            this.printed = true;
            ret += String.format("%d [label=\"%s\"];",
                            counter, value.toString());
        }
        for(Node n: children){
            if (n.childrenPrinted) continue;
            n.childrenPrinted = true;
            if (!ret.equals("")) ret += "\n";
            ret += String.format("%d -> %d;", this.counter, n.counter);
            ret += "\n" + n.toString();
        }
      return ret;
    }
  }

  private Lexer lexer;

  public Parser(Lexer lex) {
    super(lex);
    lexer = lex;
  }

  public void syntax_error(Symbol current_token) {
  report_error(
  "Syntax error at line " + (current_token.left+1) + ", column "
  + current_token.right, null
  );
}

:};

/**
  * TERMINALS
  */

// Identifier
terminal ID;
// Basic data representations
terminal INTEGER, FLOAT, BOOL, CHAR, STRING;
// Boolean
terminal NOT, AND, OR, IMPLIC;
// Bracket extravaganza
terminal LPAREN, RPAREN; // ()
terminal LCURLY, RCURLY; // {}
terminal LSQUARE, RSQUARE; // []
terminal LANGLE, RANGLE; // <>
// Arithemtic operators
terminal PLUS, MINUS, MULT, DIV, POW;
// Comparions operators
terminal EQ, LESS, LESS_EQ; // =, <, <=
// Dictionaries and sequences (collections)
terminal DICT, SEQ, IN; // dict, seq
//Field stuff
terminal FULLSTOP, ALIAS;
// Types
terminal TYPE_BOOL, TYPE_CHAR, TYPE_INT, TYPE_RAT, TYPE_FLOAT, TYPE_TOP;
// Other operators
terminal CONCAT, SEMICOL, COLON, ASSIGN, COMMA, UNDERSCORE; // ::, ;, :, :=, \,, _
// Comments
terminal MULTI_LINE_COMMENT, SINGLE_LINE_COMMENT; // /#...#/, #...

// TODO: Test that function actually returns something of that type (i.e. if func is supposed to have return type int, check there's return int somewhere)
// TODO: Test for allowed/disallowed ASCII characters as string/char AND for variable names
// TODO: Test for function calls/predicates before call
// TODO: Test for capital s in seq, and variations of this
// TODO: Implication
// TODO: Seq length checking
// TODO: Rationals
// TODO: Loop
// TODO: If
// TODO: Break
// TODO: Test Function calls
// TODO: Don't allow keywords as e.g. function names
// TODO: Null value
// TODO: Alias
// TODO: Are declarations only allowed before main?
// TODO: In function, declarations have to occur first
/**
  * NON-TERMINALS
  */
nonterminal element;
// Variables and types
nonterminal variable_decl_init, var_decl, type, maybe_type_decl, type_decl, type_def;
nonterminal zero_or_more_type_def_pairs, no_trailing_colon_type_def_pairs, type_def_element;
nonterminal type_seq, type_dict, collect_type;
// Functions
nonterminal global_declaration_except_main;
// Comments
nonterminal any_comment;
// Parameters
nonterminal top_level_formal_parameter_list, formal_parameter_list, formal_parameter;
// Sequence
nonterminal seq_concat, evaluates_to_seq_or_id, seq_definition, no_trailing_comma_expressions, zero_or_more_comma_separated_expressions;
nonterminal slicing, maybe_slicing_simple_exp;
// Dict
nonterminal dict_definition, no_trailing_comma_k_v_pairs, zero_or_more_k_v_pairs, dict_element;
// Boolean
nonterminal bool_expr, evaluates_to_bool, evaluates_to_bool_or_id, bool_oper, in_expr;

/**
  * OLD STUFF
  */

// Do something with ILLEGAL_CHARARCTER or drop it.
terminal BADCHAR; //TODO: Return this? When is it used?
terminal PRINT, READ, RETURN, MAIN, FDEF, TDEF;
nonterminal stmnts, stmnt, top_level;
nonterminal full_exp, simple_exp, boolean_or_simple, operator;
nonterminal print_statement, read_statement, return_statement, alias_statement;
nonterminal funcs_or_main, main_func, normal_func, normal_func_body;
nonterminal funcs_or_global_decls, global_declarations, func_param_decl, func_body_no_return, func_body_with_return;

precedence left AND, OR, IMPLIC;
precedence left NOT;
precedence left EQ, LESS, LESS_EQ, IN;
precedence left PLUS, MINUS;
precedence left DIV, MULT;
precedence left POW;
precedence left CONCAT;
precedence left FULLSTOP;
precedence left ID; //TODO: Delete this line if necessary, it is a dirty hack
top_level
::=
    funcs_or_global_decls:fog {: if(debug()) System.out.println((Node)fog); :}
;


funcs_or_global_decls // TODO: Add global variables to this
::=
    funcs_or_main:fs {:RESULT=Node.n(fs);:}
;


//TODO add empty return for main (or any function)
//TODO add error code return for main
main_func
::=
    MAIN func_param_decl:p func_body_no_return:fb {:RESULT=Node.n("MAIN_FUNC", p, fb);:}
  | MAIN func_body_no_return:fb {:RESULT=Node.n("MAIN_FUNC", fb);:}
;

any_comment
::=
    SINGLE_LINE_COMMENT {:RESULT=Node.n("SINGLE_LINE_COMMENT");:}
  | MULTI_LINE_COMMENT {:RESULT=Node.n("MULTI_LINE_COMMENT");:}
;

funcs_or_main
::=
   global_declarations:gd1  main_func:mf global_declarations:gd2 {:RESULT=Node.n("MAIN_THEN_FUNC", gd1, mf, gd2);:};
//  | global_declaration_except_main:gd funcs_or_main:fum {:RESULT=Node.n("DECL_THEN_MAYBE_MAIN", gd, fum);:}
//;

global_declarations
::=
    global_declaration_except_main:f global_declarations:fs {:RESULT=Node.n("FUNC_THEN_FUNCS", f, fs);:}
  | /* nuffin */ {:RESULT=Node.n("FUNCS_END");:}
;

global_declaration_except_main
::=
    any_comment:c {:RESULT=Node.n(c);:}
  | normal_func:f {:RESULT=Node.n(f);:}
  | variable_decl_init:v {:RESULT=Node.n(v);:}
  | type_def:td {:RESULT=Node.n(td);:}
  | alias_statement:as {:RESULT=Node.n(as);:}
;

type_def
::=
    TDEF ID:i LCURLY zero_or_more_type_def_pairs:dd RCURLY SEMICOL {:RESULT=Node.n("TDEF", i, dd);:}
;

zero_or_more_type_def_pairs
::=
    no_trailing_colon_type_def_pairs:kv {: RESULT=Node.n(kv); :}
  | /* nuffin */ {:RESULT=Node.n("EMPTY_TDEF");:}
;

no_trailing_colon_type_def_pairs
::=
     type_def_element:kv COMMA no_trailing_colon_type_def_pairs:kvs {:RESULT=Node.n("NON_ENDING_KV_LIST", kv, kvs);:}
   | type_def_element:kv {:RESULT=Node.n(kv);:}

;

type_def_element
::= boolean_or_simple:k COLON type:v {:RESULT=Node.n("TYPE_DEF_ELEM", k, v);:}
;

normal_func
::=
    FDEF ID:i func_param_decl:p normal_func_body:fb {:RESULT=Node.n("FDEF", i, p, fb);:}
;


func_param_decl
::=
    LPAREN top_level_formal_parameter_list RPAREN {:RESULT=Node.n("PARAM_DECL");:}
;

top_level_formal_parameter_list
::=
    formal_parameter_list:ne {:RESULT=Node.n(ne);:}
   | /* nuffin */ {:RESULT=Node.n("NO_PARAMS");:}
;

formal_parameter_list
::= var_decl:f COMMA formal_parameter_list:fl {:RESULT=Node.n("NON_ENDING_PARAMS_LIST", f, fl);:}
   | var_decl:f {:RESULT=Node.n(f);:}
;

normal_func_body
::=
    func_body_no_return:n {:RESULT=Node.n(n);:}
  | func_body_with_return:r{:RESULT=Node.n(r);:}
;

// TODO: Add declaration between statements
func_body_no_return
::=
    LCURLY stmnts:ss RCURLY SEMICOL {:RESULT=Node.n("FUNC_BODY_NO_RETURN", ss);:}
;

func_body_with_return
::=
    LCURLY stmnts:ss RCURLY type_decl:td SEMICOL {:RESULT=Node.n("FUNC_BODY_WITH_RETURN", ss, td);:}
;

stmnts
::=
    stmnt:s {:RESULT=Node.n(s);:} //TODO: Enforce that declarations come before the other stuff
  | stmnt:s stmnts:ss {:RESULT=Node.n(s, ss);:}
;

stmnt
::=
    variable_decl_init:s {:RESULT=Node.n(s);:}
  | any_comment:c {:RESULT=Node.n(c);:}
  | read_statement:r {:RESULT=Node.n(r);:}
  | print_statement:p {:RESULT=Node.n(p);:}
  | return_statement:re {:RESULT=Node.n(re);:}
  | alias_statement:as {:RESULT=Node.n(as);:}
  | type_def:td {:RESULT=Node.n(td);:}
;

alias_statement
::=
    ALIAS type:t ID:i SEMICOL {:RESULT=Node.n("ALIAS", t, i);:}
;

full_exp
::=
    boolean_or_simple:be SEMICOL {:RESULT=Node.n(be);:}
;

boolean_or_simple
::=
    bool_expr:be {:RESULT=Node.n(be);:}
  | simple_exp:se {:RESULT=Node.n(se);:}
;

//TODO: Describe syntax of rationals in ambiguities.txt
simple_exp
::=
    INTEGER:i {:RESULT=Node.n(i);:}
  | FLOAT:i {:RESULT=Node.n(i);:}
  | INTEGER:i UNDERSCORE INTEGER:j DIV INTEGER:k {:RESULT=Node.n("MIXED_RAT", i, j, k);:}
  | CHAR:i {:RESULT=Node.n("CHARVAR");:}
  | STRING:i {:RESULT=Node.n("STRING");:}
  | simple_exp:sd CONCAT simple_exp:sq {:RESULT=Node.n("SEQ_CONCAT", sd, sq);:}
//  | seq_concat:s {:RESULT=Node.n(s);:}
//  | ID:i {:RESULT=Node.n(i);:}
  | element:e {:RESULT=Node.n(e); :}
  | seq_definition:s {:RESULT=Node.n(s); :}
  | dict_definition:d {:RESULT=Node.n(d);:}
  | simple_exp:e1 operator:o simple_exp:e2 {:RESULT=Node.n(o, e1, e2);:}
  | LPAREN simple_exp:e RPAREN {:RESULT=Node.n("PARENS", "(", e, ")");:}
;

bool_expr
::=
   evaluates_to_bool:etb {:RESULT=Node.n(etb);:}
 | evaluates_to_bool_or_id:etb1 bool_oper:bo evaluates_to_bool_or_id:etb2 {:RESULT=Node.n(bo, etb1, etb2);:}
 | NOT bool_expr:be {:RESULT=Node.n("NOT", be);:}
 | in_expr:ie {:RESULT=Node.n(ie);:}
;

//TODO: Reason about precedence of in operator
//TODO: `simple_exp`? Really? Only `ID` can work here. -Tim
in_expr
::=
   simple_exp:se IN ID:i {:RESULT=Node.n(se, "in", i);:}
 | simple_exp:se IN dict_definition:i {:RESULT=Node.n("in", se, i);:}
 | simple_exp:se IN seq_definition:i {:RESULT=Node.n("in", se, i);:}
;

evaluates_to_bool_or_id
::=
    evaluates_to_bool:etb {:RESULT=Node.n(etb);:}
  | ID:i {:RESULT=Node.n(i);:}
;

// TODO: Addeth function calls
evaluates_to_bool
::=
    BOOL {:RESULT=Node.n("BOOL");:}
  | LPAREN bool_expr:be RPAREN {:RESULT=Node.n(be);:}
;

bool_oper
::=
    AND    {:RESULT=Node.n("&&");:}
  | OR     {:RESULT=Node.n("||");:}
  | IMPLIC {:RESULT=Node.n("=>");:}
;

/*seq_concat
::=
//  | evaluates_to_seq_or_id:sd {:RESULT=Node.n(sd);:}
;*/

/*
evaluates_to_seq_or_id
::=
    seq_definition:sd {:RESULT=Node.n(sd);:}
//  | ID:i {:RESULT=Node.n("ID: " + i);:}
  | evaluates_to_seq_or_id:se slicing:sl {://RESULT=Node.n("SLICED_SEQ", se, sl);:}
;*/

slicing
::=
    LSQUARE maybe_slicing_simple_exp:s COLON maybe_slicing_simple_exp:e RSQUARE {:RESULT=Node.n("SLICING", s, e);:}
;

maybe_slicing_simple_exp
::=
    simple_exp:se {:RESULT=Node.n(se);:}
  | /* nuffins */ {:RESULT=Node.n("EMPTY");:}
;

seq_definition
::=
    LSQUARE zero_or_more_comma_separated_expressions:exp RSQUARE {:RESULT=Node.n("SEQ_DEF", exp);:}
;

//TODO: Say in ambiguities.txt that we allow expressions in seq's
zero_or_more_comma_separated_expressions
::=
    no_trailing_comma_expressions:ne {:RESULT=Node.n(ne);:}
   | /* nuffin */ {:RESULT=Node.n("EMPTY_SEQ");:}
;

no_trailing_comma_expressions
::=
     boolean_or_simple:e COMMA no_trailing_comma_expressions:es {:RESULT=Node.n("NON_ENDING_COMMA_LIST", e, es);:}
   | boolean_or_simple:e {:RESULT=Node.n(e);:}
;

dict_definition
::=
   LCURLY zero_or_more_k_v_pairs:kv RCURLY {:RESULT=Node.n("DICT_DEF", kv);:}
;

zero_or_more_k_v_pairs
::=
    no_trailing_comma_k_v_pairs:kv {: RESULT=Node.n(kv); :}
  | /* nuffin */ {:RESULT=Node.n("EMPTY_DICT");:}
;

no_trailing_comma_k_v_pairs
::=
     dict_element:kv COMMA no_trailing_comma_k_v_pairs:kvs {:RESULT=Node.n("NON_ENDING_KV_LIST", kv, kvs);:}
   | dict_element:kv {:RESULT=Node.n(kv);:}

;

dict_element
::= boolean_or_simple:k COLON boolean_or_simple:v {:RESULT=Node.n("DICT_ELEM", k, v);:}
;

read_statement
::=
    READ ID:i SEMICOL {:RESULT=Node.n("READ", i);:}
;

print_statement
::=
    PRINT full_exp:e {:RESULT=Node.n("PRINT", e);:}
;

return_statement
::=
    RETURN full_exp:e {:RESULT = Node.n("RETURN", e);:}
  | RETURN {:RESULT=Node.n("RETURN_HACK");:} //TODO: Fix return, bc right now we allow e.g. return; something;
;

operator
::=
    PLUS  {:RESULT=Node.n("+");:}
  | MINUS {:RESULT=Node.n("-");:}
  | MULT  {:RESULT=Node.n("*");:}
  | DIV   {:RESULT=Node.n("/");:}
  | POW   {:RESULT=Node.n("^");:}
;

variable_decl_init
::=
    element:e1 ASSIGN full_exp:e2 {:RESULT=Node.n("ASSIGNMENT", e1, e2);:}
  | var_decl:v ASSIGN full_exp:e {:RESULT=Node.n("ASSIGNMENT", v, e);:}
  | var_decl:v SEMICOL {:RESULT=Node.n(v);:}
;

element
::=
    ID:i {:RESULT=Node.n(i);:}
  | element:b LSQUARE simple_exp:i RSQUARE {:RESULT=Node.n(b, "Index", i);:}
  | element:b slicing:sl {:RESULT=Node.n("SLICED_SEQ", b, sl);:}
  | element:e1 FULLSTOP element:e2 {:RESULT=Node.n("FIELD_REFERENCE", e1, e2);:}
;

var_decl
::=
    ID:i type_decl:td {:RESULT=Node.n("DECLARATION", i ,td);:}
;

type_decl
::=
    COLON type:t {:RESULT=Node.n("TYPE DECLARATION", t);:}
;

type
::=
    TYPE_BOOL   {:RESULT=Node.n("BOOL");:}
  | TYPE_CHAR   {:RESULT=Node.n("CHAR");:}
  | TYPE_INT    {:RESULT=Node.n("INT");:}
  | TYPE_RAT    {:RESULT=Node.n("RAT");:}
  | TYPE_FLOAT  {:RESULT=Node.n("FLOAT");:}
  | type_seq:s  {:RESULT=Node.n(s);:}
  | type_dict:d {:RESULT=Node.n(d);:}
  | ID:i        {:RESULT=Node.n("CUSTOM_TYPE", i);:}
;

collect_type
::=
    type:t   {:RESULT=Node.n(t);:}
  | TYPE_TOP {:RESULT=Node.n("TOP");:}
;

type_seq
::=
    SEQ LANGLE collect_type:t RANGLE {:RESULT=Node.n("SEQ", t);:}
;

type_dict
::=
    DICT LANGLE type:t1 COMMA collect_type:t2 RANGLE {:RESULT = Node.n("DICT", t1, t2);:}
;

