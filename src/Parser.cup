import java_cup.runtime.*;
import java.util.ArrayList;

scan with {: return lexer.next_token(); :};

parser code {:

  public boolean  debug(){return debug;}
  public void     debug(boolean b){debug = b;}
  public boolean  syntaxErrors;
  private boolean debug = true;

  static class Node {
    public ArrayList<Node> children;
    private static int globalCounter = 0;

    public int counter;
    private Object value;

    public Node(Object value){
      Node.globalCounter += 1;
      this.counter = Node.globalCounter;
      this.value = value;
      this.children = new ArrayList<Node>();
    }

    public void addChild(Node n){ children.add(n); }

    public String toString(){
      String ret = "";
      ret += String.format("%d [label=\"%s\"];\n",
                            counter, value.toString());
      for(Node n: children){
        ret += String.format("%d -> %d;\n", this.counter, n.counter);
        ret += n.toString();
      }
      return ret;
    }
  }

  private Lexer lexer;

  public Parser(Lexer lex) {
    super(lex);
    lexer = lex;
  }

  public void syntax_error(Symbol current_token) {
  report_error(
  "Syntax error at line " + (current_token.left+1) + ", column "
  + current_token.right, null
  );
}

:};

// Bracket extravaganza
terminal LPAREN, RPAREN; // ()
terminal LCURLY, RCURLY; // {}

// Arithemtic operators
terminal PLUS, MINUS, MULT, DIV;

// Comparions operators
terminal EQ, LESS, LESS_EQ; // =, <, <=

// Dictionaries and sequences (collections)
terminal DICT_START, SEQ_START, COLLECT_END; // dict<, seq<, collect_end

// Other operators
terminal CONCOT, SEMICOL; // :, ;

// Do something with ILLEGAL_CHARARCTER or drop it.
terminal INTEGER, FLOAT, BOOL, CHAR, IDENTIFIER, LET, EQUAL;
terminal BADCHAR; //TODO: Return this? When is it used?
terminal PRINT, READ, MAIN, FDEF;

nonterminal statements, statement, top_level;
nonterminal let_bind, full_exp, simple_exp, operator;
nonterminal print_statement, read_statement;
// TODO: Fucking nuke the existing let_bind shit and use declarations instead
nonterminal functions_or_main, main_function, normal_function;
nonterminal functions_or_global_declarations, functions, function_body;

precedence left PLUS, MINUS;
precedence left DIV, MULT;

top_level ::= functions_or_global_declarations:fog {:
                if(debug()) System.out.println((Node)fog);
              :}
            ;

// TODO: Add global variables to this
functions_or_global_declarations ::= functions_or_main:fs {: RESULT = (Node) fs; :};


main_function ::= MAIN function_body:fb {:
                          Node n = new Node("MainFunc");
                          n.addChild((Node) fb);
                          RESULT = n;
                    :};

functions_or_main ::= main_function:mf functions:fu {:
                          Node n = (Node) mf;
                          n.addChild((Node) fu);
                          RESULT = n;
                      :}
                    | normal_function:nf functions_or_main:fum {:
                          Node n = (Node) nf;
                          n.addChild((Node) fum);
                          RESULT = n;
                      :};

functions ::= normal_function:f functions:fs {:
                    // TODO: Fix node generation
                    Node n = (Node)fs;
                    n.addChild((Node)f);
                    RESULT = n;
               :}
               | /* nuffin */ {: RESULT = new Node("Functions"); :}
               ;

// TODO: Add method parameters (a.k.a. function arguments)
// TODO: Add return param
normal_function ::= FDEF IDENTIFIER:i function_body:fb {:
                    Node n = new Node("FDef");
                    n.addChild((Node) i);
                    n.addChild((Node) fb);
                    RESULT = (Node) n;
                    :};

// TODO: Add declaration between statements
function_body ::= LCURLY statements:ss RCURLY SEMICOL {:
    Node n = new Node("Function Body");
    n.addChild((Node) ss);
    RESULT = n;
:};

statements ::= statements:ss statement:s {:
                  Node n = (Node)ss;
                  n.addChild((Node)s);
                  RESULT = n;
               :}
             | statement:s {: RESULT = (Node) s; :}
             ;

statement ::= let_bind:s {:
                RESULT = (Node)s;
              :}
            | full_exp:s {:
                RESULT = (Node)s;
              :}
             | read_statement:r {: RESULT = (Node) r; :}
             | print_statement:p {: RESULT = (Node) p; :}
            ;

full_exp ::= simple_exp:e SEMICOL {: RESULT = (Node)e; :};

simple_exp ::= INTEGER:i    {: RESULT = new Node(i); :}
             | IDENTIFIER:i {: RESULT = new Node(i); :}
             | simple_exp:e1 operator:o simple_exp:e2 {:
                  Node n = (Node)o;
                  n.addChild((Node)e1);
                  n.addChild((Node)e2);
                  RESULT = n;
               :}
             | LPAREN simple_exp:e RPAREN {:
                 Node n = new Node("parens");
                 n.addChild(new Node("("));
                 n.addChild((Node)e);
                 n.addChild(new Node(")"));
                 RESULT = (Node)e;
               :}
             ;

read_statement ::= READ IDENTIFIER:i SEMICOL {:
                    Node n = new Node("READ");
                    n.addChild(new Node(i));
                    RESULT = n;
                :}
                ;
print_statement ::= PRINT full_exp:e {:
                    Node n = new Node("PRINT");
                    n.addChild((Node) e);
                    RESULT = n;
                :}
                ;

operator ::= PLUS  {: RESULT = new Node("+"); :}
           | MINUS {: RESULT = new Node("-"); :}
           | MULT  {: RESULT = new Node("*"); :}
           | DIV   {: RESULT = new Node("/"); :}
           ;

let_bind ::= LET IDENTIFIER:i EQUAL full_exp:e {:
               Node n = new Node("LET");
               n.addChild(new Node(i));
               n.addChild((Node)e);
               RESULT = n;
             :};
